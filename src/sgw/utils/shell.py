"""Shell autocompletion generation utilities."""

from __future__ import annotations

from pathlib import Path
from typing import Optional

from sgw.utils.xdg import APP_NAME


def get_completion_path(shell: str) -> Path:
    """Get the default installation path for completion scripts.

    Args:
        shell: Shell name (bash, zsh, fish).

    Returns:
        Path where completion script should be installed.

    Raises:
        ValueError: If shell is not supported.
    """
    home = Path.home()

    if shell == "bash":
        return home / ".bash_completion.d" / APP_NAME
    elif shell == "zsh":
        return home / ".zsh" / "completions" / f"_{APP_NAME}"
    elif shell == "fish":
        return home / ".config" / "fish" / "completions" / f"{APP_NAME}.fish"
    else:
        raise ValueError(f"Unsupported shell: {shell}. Must be one of: bash, zsh, fish")


def generate_bash_completion() -> str:
    """Generate bash completion script.

    Returns:
        Bash completion script content.
    """
    return f'''# Bash completion for {APP_NAME}
# Generated by {APP_NAME} init shell bash

_{APP_NAME}_completions() {{
    local cur prev opts
    COMPREPLY=()
    cur="${{COMP_WORDS[COMP_CWORD]}}"
    prev="${{COMP_WORDS[COMP_CWORD-1]}}"

    # Main commands
    local commands="clone add remove pull migrate init"

    # Options
    local global_opts="--help --verbose --quiet"

    case "${{COMP_CWORD}}" in
        1)
            COMPREPLY=( $(compgen -W "${{commands}}" -- "${{cur}}") )
            return 0
            ;;
    esac

    case "${{prev}}" in
        clone)
            # No specific completions for clone URI
            return 0
            ;;
        add)
            # Complete with branch names
            if git rev-parse --git-dir > /dev/null 2>&1; then
                local branches=$(git branch --format='%(refname:short)' 2>/dev/null)
                local remote_branches=$(git branch -r --format='%(refname:short)' 2>/dev/null | sed 's/origin\\///')
                COMPREPLY=( $(compgen -W "${{branches}} ${{remote_branches}}" -- "${{cur}}") )
            fi
            return 0
            ;;
        remove)
            # Complete with worktree branches or paths
            if git rev-parse --git-dir > /dev/null 2>&1; then
                local worktrees=$(git worktree list --porcelain 2>/dev/null | grep '^branch ' | sed 's/branch refs\\/heads\\///')
                COMPREPLY=( $(compgen -W "${{worktrees}}" -- "${{cur}}") )
            fi
            return 0
            ;;
        init)
            COMPREPLY=( $(compgen -W "config shell" -- "${{cur}}") )
            return 0
            ;;
        shell)
            COMPREPLY=( $(compgen -W "bash zsh fish" -- "${{cur}}") )
            return 0
            ;;
        migrate)
            # Complete with directories
            COMPREPLY=( $(compgen -d -- "${{cur}}") )
            return 0
            ;;
        -c|--create-branch)
            return 0
            ;;
        -f|--force)
            return 0
            ;;
        --dry-run|-n|--move)
            return 0
            ;;
    esac

    # Default to global options
    COMPREPLY=( $(compgen -W "${{global_opts}}" -- "${{cur}}") )
    return 0
}}

complete -F _{APP_NAME}_completions {APP_NAME}
'''


def generate_zsh_completion() -> str:
    """Generate zsh completion script.

    Returns:
        Zsh completion script content.
    """
    return f'''#compdef {APP_NAME}
# Zsh completion for {APP_NAME}
# Generated by {APP_NAME} init shell zsh

_sgw() {{
    local -a commands
    commands=(
        'clone:Clone a repository to configured location'
        'add:Add a worktree for a branch'
        'remove:Remove a worktree'
        'pull:Update source repository'
        'migrate:Migrate repositories to new locations'
        'init:Initialize config or shell completion'
    )

    local -a init_commands
    init_commands=(
        'config:Create default configuration file'
        'shell:Install shell completion'
    )

    local -a shells
    shells=(bash zsh fish)

    _arguments -C \\
        '1: :->command' \\
        '*: :->args' \\
        && return 0

    case $state in
        command)
            _describe -t commands 'sgw command' commands
            ;;
        args)
            case $words[2] in
                clone)
                    _message 'repository URI'
                    ;;
                add)
                    _arguments \\
                        '-c[Create branch if not exists]' \\
                        '--create-branch[Create branch if not exists]' \\
                        '1:branch:_git_branch_names' \\
                        '2:worktree name:'
                    ;;
                remove)
                    _arguments \\
                        '-f[Force removal]' \\
                        '--force[Force removal]' \\
                        '1:branch or path:_git_branch_names'
                    ;;
                pull)
                    ;;
                migrate)
                    _arguments \\
                        '-n[Dry run]' \\
                        '--dry-run[Dry run]' \\
                        '--move[Move instead of copy]' \\
                        '1:old repos directory:_files -/'
                    ;;
                init)
                    case $words[3] in
                        shell)
                            _describe -t shells 'shell' shells
                            ;;
                        *)
                            _describe -t init_commands 'init command' init_commands
                            ;;
                    esac
                    ;;
            esac
            ;;
    esac
}}

_git_branch_names() {{
    local -a branches
    if git rev-parse --git-dir > /dev/null 2>&1; then
        branches=($(git branch --format='%(refname:short)' 2>/dev/null))
        _describe -t branches 'branch' branches
    fi
}}

_sgw "$@"
'''


def generate_fish_completion() -> str:
    """Generate fish completion script.

    Returns:
        Fish completion script content.
    """
    return f'''# Fish completion for {APP_NAME}
# Generated by {APP_NAME} init shell fish

# Disable file completions for all commands
complete -c {APP_NAME} -f

# Main commands
complete -c {APP_NAME} -n __fish_use_subcommand -a clone -d 'Clone a repository'
complete -c {APP_NAME} -n __fish_use_subcommand -a add -d 'Add a worktree'
complete -c {APP_NAME} -n __fish_use_subcommand -a remove -d 'Remove a worktree'
complete -c {APP_NAME} -n __fish_use_subcommand -a pull -d 'Update source repository'
complete -c {APP_NAME} -n __fish_use_subcommand -a migrate -d 'Migrate repositories'
complete -c {APP_NAME} -n __fish_use_subcommand -a init -d 'Initialize config or completion'

# clone completions
# (no specific completions for URI)

# add completions
complete -c {APP_NAME} -n '__fish_seen_subcommand_from add' -s c -l create-branch -d 'Create branch if not exists'
complete -c {APP_NAME} -n '__fish_seen_subcommand_from add' -a '(__fish_git_branches)'

# remove completions
complete -c {APP_NAME} -n '__fish_seen_subcommand_from remove' -s f -l force -d 'Force removal'
complete -c {APP_NAME} -n '__fish_seen_subcommand_from remove' -a '(__fish_git_branches)'

# migrate completions
complete -c {APP_NAME} -n '__fish_seen_subcommand_from migrate' -s n -l dry-run -d 'Show what would be migrated'
complete -c {APP_NAME} -n '__fish_seen_subcommand_from migrate' -l move -d 'Move instead of copy'
complete -c {APP_NAME} -n '__fish_seen_subcommand_from migrate' -a '(__fish_complete_directories)'

# init subcommands
complete -c {APP_NAME} -n '__fish_seen_subcommand_from init; and not __fish_seen_subcommand_from config shell' -a config -d 'Create default config file'
complete -c {APP_NAME} -n '__fish_seen_subcommand_from init; and not __fish_seen_subcommand_from config shell' -a shell -d 'Install shell completion'

# init shell completions
complete -c {APP_NAME} -n '__fish_seen_subcommand_from init; and __fish_seen_subcommand_from shell' -a 'bash zsh fish'

# Global options
complete -c {APP_NAME} -s h -l help -d 'Show help'
complete -c {APP_NAME} -s v -l verbose -d 'Increase verbosity'
complete -c {APP_NAME} -s q -l quiet -d 'Suppress output'
'''


def generate_completion(shell: str) -> str:
    """Generate completion script for specified shell.

    Args:
        shell: Shell name (bash, zsh, fish).

    Returns:
        Completion script content.

    Raises:
        ValueError: If shell is not supported.
    """
    if shell == "bash":
        return generate_bash_completion()
    elif shell == "zsh":
        return generate_zsh_completion()
    elif shell == "fish":
        return generate_fish_completion()
    else:
        raise ValueError(f"Unsupported shell: {shell}. Must be one of: bash, zsh, fish")


def install_completion(shell: str, path: Optional[Path] = None) -> Path:
    """Install completion script for specified shell.

    Args:
        shell: Shell name (bash, zsh, fish).
        path: Custom installation path (optional).

    Returns:
        Path where script was installed.

    Raises:
        ValueError: If shell is not supported.
        OSError: If installation fails.
    """
    if path is None:
        path = get_completion_path(shell)

    script = generate_completion(shell)

    # Ensure parent directory exists
    path.parent.mkdir(parents=True, exist_ok=True)

    # Write script
    path.write_text(script)

    return path


def get_installation_instructions(shell: str, path: Path) -> str:
    """Get instructions for activating completion after installation.

    Args:
        shell: Shell name.
        path: Path where completion was installed.

    Returns:
        Human-readable activation instructions.
    """
    if shell == "bash":
        return (
            f"Installed bash completion script: {path}\n"
            f"To activate, run: source {path}\n"
            f"Or add to ~/.bashrc: source {path}"
        )
    elif shell == "zsh":
        return (
            f"Installed zsh completion script: {path}\n"
            f"To activate, ensure your ~/.zshrc contains:\n"
            f"  fpath=(~/.zsh/completions $fpath)\n"
            f"  autoload -Uz compinit && compinit\n"
            f"Then restart your shell."
        )
    elif shell == "fish":
        return (
            f"Installed fish completion script: {path}\n"
            f"Restart fish shell or run: source {path}"
        )
    else:
        return f"Installed completion script: {path}"
